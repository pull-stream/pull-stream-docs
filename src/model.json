{"contributors":[{"name":"dominictarr","avatar":"https://avatars.githubusercontent.com/u/259374?v=3"},{"name":"regular","avatar":"https://avatars.githubusercontent.com/u/122962?v=3"},{"name":"0x00A","avatar":"https://avatars.githubusercontent.com/u/136109?v=3"},{"name":"timoxley","avatar":"https://avatars.githubusercontent.com/u/43438?v=3"},{"name":"anko","avatar":"https://avatars.githubusercontent.com/u/5231746?v=3"},{"name":"zetxx","avatar":"https://avatars.githubusercontent.com/u/704384?v=3"},{"name":"joliss","avatar":"https://avatars.githubusercontent.com/u/524783?v=3"},{"name":"yoshuawuyts","avatar":"https://avatars.githubusercontent.com/u/2467194?v=3"},{"name":"TehShrike","avatar":"https://avatars.githubusercontent.com/u/1141869?v=3"},{"name":"ungoldman","avatar":"https://avatars.githubusercontent.com/u/427322?v=3"},{"name":"pfraze","avatar":"https://avatars.githubusercontent.com/u/1270099?v=3"},{"name":"noffle","avatar":"https://avatars.githubusercontent.com/u/489362?v=3"},{"name":"ahdinosaur","avatar":"https://avatars.githubusercontent.com/u/719605?v=3"},{"name":"tounano","avatar":"https://avatars.githubusercontent.com/u/5513418?v=3"},{"name":"mvayngrib","avatar":"https://avatars.githubusercontent.com/u/83948?v=3"},{"name":"CoderPuppy","avatar":"https://avatars.githubusercontent.com/u/714198?v=3"},{"name":"clehner","avatar":"https://avatars.githubusercontent.com/u/95347?v=3"},{"name":"DamonOehlman","avatar":"https://avatars.githubusercontent.com/u/609693?v=3"},{"name":"reqshark","avatar":"https://avatars.githubusercontent.com/u/937826?v=3"},{"name":"sastan","avatar":"https://avatars.githubusercontent.com/u/514405?v=3"},{"name":"iankronquist","avatar":"https://avatars.githubusercontent.com/u/5192353?v=3"},{"name":"adjohnson916","avatar":"https://avatars.githubusercontent.com/u/615381?v=3"}],"categories":["core","combinators","push","file system and databases","text","binary","networks","interop","crypto"],"modules":[{"user":"pull-stream","name":"pull-stream","path":"pull-stream/pull-stream","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream\">pull-stream</a><div class=\"contrib\"></div></h1>\n<p>Minimal Pipeable Pull-stream</p>\n<p>In <a href=\"https://github.com/nodejs/node-v0.x-archive/blob/v0.8/doc/api/stream.markdown\">classic-streams</a>,\nstreams <em>push</em> data to the next stream in the pipeline.\nIn <a href=\"https://github.com/nodejs/node-v0.x-archive/blob/v0.10/doc/api/stream.markdown\">new-streams</a>,\ndata is pulled out of the source stream, into the destination.\n<code>pull-stream</code> is a minimal take on streams,\npull streams work great for &quot;object&quot; streams as well as streams of raw text or binary data.</p>\n<p><a href=\"http://travis-ci.org/dominictarr/pull-stream\"></a></p>\n<h2>Quick Example</h2>\n<p>Stat some files:</p>\n<pre><code class=\"hljs language-js\">pull(\n  pull.values([<span class=\"hljs-string\">&apos;file1&apos;</span>, <span class=\"hljs-string\">&apos;file2&apos;</span>, <span class=\"hljs-string\">&apos;file3&apos;</span>]),\n  pull.asyncMap(fs.stat),\n  pull.collect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, array</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(array)\n  })\n)</code></pre>\n<p>note that <code>pull(a, b, c)</code> is basically the same as <code>a.pipe(b).pipe(c)</code>.</p>\n<p>The best thing about pull-stream is that it can be completely lazy.\nThis is perfect for async traversals where you might want to stop early.</p>\n<h2>Compatibily with node streams</h2>\n<p>pull-streams are not <em>directly</em> compatible with node streams,\nbut pull-streams can be converted into node streams with\n<a href=\"https://github.com/dominictarr/pull-stream-to-stream\">pull-stream-to-stream</a>\nand node streams can be converted into pull-stream using <a href=\"https://github.com/dominictarr/stream-to-pull-stream\">stream-to-pull-stream</a></p>\n<h3>Readable &amp; Reader vs. Readable &amp; Writable</h3>\n<p>Instead of a readable stream, and a writable stream, there is a <code>readable</code> stream,\n(aka &quot;Source&quot;) and a <code>reader</code> stream (aka &quot;Sink&quot;). Through streams\nis a Sink that returns a Source.</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://github.com/dominictarr/pull-stream/blob/master/docs/sources.md\">Sources</a></li>\n<li><a href=\"https://github.com/dominictarr/pull-stream/blob/master/docs/throughs.md\">Throughs</a></li>\n<li><a href=\"https://github.com/dominictarr/pull-stream/blob/master/docs/sinks.md\">Sinks</a></li>\n</ul>\n<h3>Source (aka, Readable)</h3>\n<p>The readable stream is just a <code>function read(end, cb)</code>,\nthat may be called many times,\nand will (asynchronously) <code>cb(null, data)</code> once for each call.</p>\n<p>To signify an end state, the stream eventually returns <code>cb(err)</code> or <code>cb(true)</code>.\nWhen indicating a terminal state, <code>data</code> <em>must</em> be ignored.</p>\n<p>The <code>read</code> function <em>must not</em> be called until the previous call has called back.\nUnless, it is a call to abort the stream (<code>read(truthy, cb)</code>).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//a stream of 100 random numbers.</span>\n<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-keyword\">var</span> random = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">end, cb</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(end) <span class=\"hljs-keyword\">return</span> cb(end)\n    <span class=\"hljs-comment\">//only read 100 times</span>\n    <span class=\"hljs-keyword\">if</span>(i-- <span class=\"xml\"><span class=\"hljs-tag\">&lt; <span class=\"hljs-attr\">0</span>) <span class=\"hljs-attr\">return</span> <span class=\"hljs-attr\">cb</span>(<span class=\"hljs-attr\">true</span>)\n    <span class=\"hljs-attr\">cb</span>(<span class=\"hljs-attr\">null</span>, <span class=\"hljs-attr\">Math.random</span>())\n  }\n}</span></span></code></pre>\n<h3>Sink; (aka, Reader, &quot;writable&quot;)</h3>\n<p>A sink is just a <code>reader</code> function that calls a Source (read function),\nuntil it decideds to stop, or the readable ends. <code>cb(err || true)</code></p>\n<p>All <a href=\"https://github.com/dominictarr/pull-stream/blob/master/docs/throughs.md\">Throughs</a>\nand <a href=\"https://github.com/dominictarr/pull-stream/blob/master/docs/sinks.md\">Sinks</a>\nare reader streams.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//read source and log it.</span>\n<span class=\"hljs-keyword\">var</span> logger = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">read</span>) </span>{\n    read(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">next</span>(<span class=\"hljs-params\">end, data</span>) </span>{\n      <span class=\"hljs-keyword\">if</span>(end === <span class=\"hljs-literal\">true</span>) <span class=\"hljs-keyword\">return</span>\n      <span class=\"hljs-keyword\">if</span>(end) <span class=\"hljs-keyword\">throw</span> end\n\n      <span class=\"hljs-built_in\">console</span>.log(data)\n      read(<span class=\"hljs-literal\">null</span>, next)\n    })\n  }\n}</code></pre>\n<p>Since these are just functions, you can pass them to each other!</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> rand = random()\n<span class=\"hljs-keyword\">var</span> log = logger()\n\nlog(rand) <span class=\"hljs-comment\">//&quot;pipe&quot; the streams.</span></code></pre>\n<p>but, it&apos;s easier to read if you use&apos;s pull-stream&apos;s <code>pull</code> method</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n\npull(random(), logger())</code></pre>\n<h3>Through</h3>\n<p>A through stream is a reader on one end and a readable on the other.\nIt&apos;s Sink that returns a Source.\nThat is, it&apos;s just a function that takes a <code>read</code> function,\nand returns another <code>read</code> function.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">read, map</span>) </span>{\n  <span class=\"hljs-comment\">//return a readable function!</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">end, cb</span>) </span>{\n    read(end, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">end, data</span>) </span>{\n      cb(end, data != <span class=\"hljs-literal\">null</span> ? map(data) : <span class=\"hljs-literal\">null</span>)\n    })\n  }\n}</code></pre>\n<h3>Pipeability</h3>\n<p>Every pipeline must go from a <code>source</code> to a <code>sink</code>.\nData will not start moving until the whole thing is connected.</p>\n<pre><code class=\"hljs language-js\">pull(source, through, sink)</code></pre>\n<p>some times, it&apos;s simplest to describe a stream in terms of other streams.\npull can detect what sort of stream it starts with (by counting arguments)\nand if you pull together through streams, it gives you a new through stream.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> tripleThrough =\n  pull(through1(), through2(), through3())\n<span class=\"hljs-comment\">//THE THREE THROUGHS BECOME ONE</span>\n\npull(source(), tripleThrough, sink())</code></pre>\n<p>pull detects if it&apos;s missing a Source by checking function arity,\nif the function takes only one argument it&apos;s either a sink or a through.\nOtherwise it&apos;s a Source.</p>\n<h2>Duplex Streams</h2>\n<p>Duplex streams, which are used to communicate between two things,\n(i.e. over a network) are a little different. In a duplex stream,\nmessages go both ways, so instead of a single function that represents the stream,\nyou need a pair of streams. <code>{source: sourceStream, sink: sinkStream}</code></p>\n<p>pipe duplex streams like this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> a = duplex()\n<span class=\"hljs-keyword\">var</span> b = duplex()\n\npull(a.source, b.sink)\npull(b.source, a.sink)\n\n<span class=\"hljs-comment\">//which is the same as</span>\n\nb.sink(a.source); a.sink(b.source)\n\n<span class=\"hljs-comment\">//but the easiest way is to allow pull to handle this</span>\n\npull(a, b, a)\n\n<span class=\"hljs-comment\">//&quot;pull from a to b and then back to a&quot;</span></code></pre>\n<h2>Design Goals &amp; Rationale</h2>\n<p>There is a deeper,\n<a href=\"http://en.wikipedia.org/wiki/Platonic_idealism\">platonic abstraction</a>,\nwhere a streams is just an array in time, instead of in space.\nAnd all the various streaming &quot;abstractions&quot; are just crude implementations\nof this abstract idea.</p>\n<p><a href=\"https://github.com/joyent/node/blob/v0.8.16/doc/api/stream.markdown\">classic-streams</a>,\n<a href=\"https://github.com/joyent/node/blob/v0.10/doc/api/stream.markdown\">new-streams</a>,\n<a href=\"https://github.com/Gozala/reducers\">reducers</a></p>\n<p>The objective here is to find a simple realization of the best features of the above.</p>\n<h3>Type Agnostic</h3>\n<p>A stream abstraction should be able to handle both streams of text and streams\nof objects.</p>\n<h3>A pipeline is also a stream.</h3>\n<p>Something like this should work: <code>a.pipe(x.pipe(y).pipe(z)).pipe(b)</code>\nthis makes it possible to write a custom stream simply by\ncombining a few available streams.</p>\n<h3>Propagate End/Error conditions.</h3>\n<p>If a stream ends in an unexpected way (error),\nthen other streams in the pipeline should be notified.\n(this is a problem in node streams - when an error occurs,\nthe stream is disconnected, and the user must handle that specially)</p>\n<p>Also, the stream should be able to be ended from either end.</p>\n<h3>Transparent Backpressure &amp; Laziness</h3>\n<p>Very simple transform streams must be able to transfer back pressure\ninstantly.</p>\n<p>This is a problem in node streams, pause is only transfered on write, so\non a long chain (<code>a.pipe(b).pipe(c)</code>), if <code>c</code> pauses, <code>b</code> will have to write to it\nto pause, and then <code>a</code> will have to write to <code>b</code> to pause.\nIf <code>b</code> only transforms <code>a</code>&apos;s output, then <code>a</code> will have to write to <code>b</code> twice to\nfind out that <code>c</code> is paused.</p>\n<p><a href=\"https://github.com/Gozala/reducers\">reducers</a> reducers has an interesting method,\nwhere synchronous tranformations propagate back pressure instantly!</p>\n<p>This means you can have two &quot;smart&quot; streams doing io at the ends, and lots of dumb\nstreams in the middle, and back pressure will work perfectly, as if the dumb streams\nare not there.</p>\n<p>This makes laziness work right.</p>\n<h3>handling end, error, and abort.</h3>\n<p>in pull streams, any part of the stream (source, sink, or through)\nmay terminate the stream. (this is the case with node streams too,\nbut it&apos;s not handled well).</p>\n<h4>source: end, error</h4>\n<p>A source may end (<code>cb(true)</code> after read) or error (<code>cb(error)</code> after read)\nAfter ending, the source <em>must</em> never <code>cb(null, data)</code></p>\n<h4>sink: abort</h4>\n<p>Sinks do not normally end the stream, but if they decide they do\nnot need any more data they may &quot;abort&quot; the source by calling <code>read(true, cb)</code>.\nA abort (<code>read(true, cb)</code>) may be called before a preceding read call\nhas called back.</p>\n<h3>handling end/abort/error in through streams</h3>\n<p>Rules for implementing <code>read</code> in a through stream:\n1) Sink wants to stop. sink aborts the through</p>\n<pre><code>just forward the exact read() call to your source,\nany future read calls should cb(true).\n</code></pre>\n<p>2) We want to stop. (abort from the middle of the stream)</p>\n<pre><code>abort your source, and then cb(true) to tell the sink we have ended.\nIf the source errored during abort, end the sink by cb read with `cb(err)`.\n(this will be an ordinary end/error for the sink)\n</code></pre>\n<p>3) Source wants to stop. (<code>read(null, cb) -&gt; cb(err||true)</code>)</p>\n<pre><code>forward that exact callback towards the sink chain,\nwe must respond to any future read calls with `cb(err||true)`.\n</code></pre>\n<p>In none of the above cases data is flowing!\n4) If data is flowing (normal operation:   <code>read(null, cb) -&gt; cb(null, data)</code></p>\n<pre><code>forward data downstream (towards the Sink)\ndo none of the above!\n</code></pre>\n<p>There either is data flowing (4) OR you have the error/abort cases (1-3), never both.</p>\n<h2>1:1 read-callback ratio</h2>\n<p>A pull stream source (and thus transform) returns <em>exactly one value</em> per read.</p>\n<p>This differs from node streams, which can use <code>this.push(value)</code> and in internal\nbuffer to create transforms that write many values from a single read value.</p>\n<p>Pull streams don&apos;t come with their own buffering mechanism, but <a href=\"https://github.com/dominictarr/pull-stream-examples/blob/master/buffering.js\">there are ways\nto get around this</a>.</p>\n<h2>Further Examples</h2>\n<ul>\n<li><a href=\"https://github.com/dominictarr/pull-stream-examples\">https://github.com/dominictarr/pull-stream-examples</a></li>\n<li><a href=\"https://github.com/pull-stream/pull-stream/blob/master/examples.md\">https://github.com/pull-stream/pull-stream/blob/master/examples.md</a></li>\n</ul>\n<p>Explore this repo further for more information about\n<a href=\"https://github.com/pull-stream/pull-stream/tree/master/sources\">sources</a>,\n<a href=\"https://github.com/pull-stream/pull-stream/tree/master/throughs\">throughs</a>,\n<a href=\"https://github.com/pull-stream/pull-stream/tree/master/sinks\">sinks</a>, and\n<a href=\"https://github.com/pull-stream/pull-stream/tree/master/docs\">more</a>.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":"3.4.1","npmName":"pull-stream","category":null},{"user":"pull-stream","name":"pull-cat","path":"pull-stream/pull-cat","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-cat\">pull-cat</a><div class=\"contrib\"></div></h1>\n<p>concatinate pull-streams</p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> cat = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-cat&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\ncat([pull.values([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]), pull.values([<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>])])\n  .pipe(...)</code></pre>\n<p>Reads from the each stream until it is finished.\nIf a stream errors, stop all the streams.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,14],"version":"1.1.8","npmName":"pull-cat","category":"combinators"},{"user":"pull-stream","name":"pull-defer","path":"pull-stream/pull-defer","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-defer\">pull-defer</a><div class=\"contrib\"></div></h1>\n<p>create a placeholder for a pull stream that won&apos;t start moving until later.</p>\n<h2>examples</h2>\n<p><code>pull-defer</code> can be used with source, sinks and transform streams.</p>\n<h3>through</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//create a deferred through stream</span>\n<span class=\"hljs-keyword\">var</span> deferred = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-defer&apos;</span>).through()\n\npull(\n  input,\n  deferred,\n  output\n)\n\n<span class=\"hljs-comment\">//nothing will happen until deferred.resolve(stream) is called.</span>\ndeferred.resolve(transform)</code></pre>\n<h3>source</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//create a deferred through stream</span>\n<span class=\"hljs-keyword\">var</span> deferred = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-defer&apos;</span>).source()\n\npull(\n  deferred,\n  output\n)\n\n<span class=\"hljs-comment\">//nothing will happen until deferred.resolve(stream) is called.</span>\ndeferred.resolve(input)</code></pre>\n<h3>sink</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//create a deferred through stream</span>\n<span class=\"hljs-keyword\">var</span> deferred = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-defer&apos;</span>).sink()\n\npull(\n  input,\n  deferred\n)\n\n<span class=\"hljs-comment\">//nothing will happen until deferred.start(stream) is called.</span>\ndeferred.resolve(output)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,15],"version":"0.2.2","npmName":"pull-defer","category":"combinators"},{"user":"pull-stream","name":"pull-many","path":"pull-stream/pull-many","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-many\">pull-many</a><div class=\"contrib\"></div></h1>\n<p>Combine many streams into one stream, as they come, while respecting back pressure.</p>\n<p>A chunk is read from each stream,\nand the next available chunk is\nselected in a round-robbin.</p>\n<p>If a any stream errors, then all the remaining streams are aborted,\nand then the sink is passed the error. If you want instead to drop the\nerroring stream, and continue reading from the other streams, you should\npipe each stream through a stream that handles the error(ignores, logs, whatever)\nand then ends normally.</p>\n<h2>Example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> many = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-many&apos;</span>)\n\npull(\n  many([\n    pull.values([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]),\n    pull.values([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>]),\n    pull.values([<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">6</span>])\n  ]),\n  pull.collect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, ary</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(err) <span class=\"hljs-keyword\">throw</span> err\n    <span class=\"hljs-built_in\">console</span>.log(ary)\n    <span class=\"hljs-comment\">//=&gt; [1, 1, 2, 2, 3, 4, 3, 5, 6]</span>\n  })\n)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.0.6","npmName":"pull-many","category":"combinators"},{"user":"pull-stream","name":"pull-merge","path":"pull-stream/pull-merge","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-merge\">pull-merge</a><div class=\"contrib\"></div></h1>\n<p>merge sorted pull-streams into one pull stream, while maintaining back-pressure.\nSource pull streams MUST be in order.</p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> merge = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-merge&apos;</span>)\n\npull(\n  merge(pull.values([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]), pull.values([<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>])),\n  pull.collect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, ary</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(err) <span class=\"hljs-keyword\">throw</span> err\n\n    <span class=\"hljs-built_in\">console</span>.log(ary)\n    <span class=\"hljs-comment\">//=&gt; [1, 2, 4, 5, 6, 7]</span>\n  })\n)</code></pre>\n<h2>signatures</h2>\n<h3>merge(left, right, compare?)</h3>\n<p>return a stream that is the merge of left and right streams.\nmerge pulls a chunk from both <code>left</code> and <code>right</code> and then\ncompares them. <code>compare</code> has the same signature as <code>Array#sort(compare)</code>.\nIf the two chunks are compared the same, the chunk from the right stream\nis taken, but the left chunk is dropped.\nOtherwise, the lowest chunk is passed to the stream.</p>\n<h3>merge([streams...], compare?)</h3>\n<p>Merge a collection of steams. This calls the first signature recursively.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.0.2","npmName":"pull-merge","category":"combinators"},{"user":"pull-stream","name":"pull-paramap","path":"pull-stream/pull-paramap","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-paramap\">pull-paramap</a><div class=\"contrib\"></div></h1>\n<p>parallel mapping pull-stream.</p>\n<p><a href=\"https://travis-ci.org/dominictarr/pull-paramap\">\n</a></p>\n<p><a href=\"http://ci.testling.com/dominictarr/pull-paramap\">\n</a></p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> paramap = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-paramap&apos;</span>)\n\npull(\n  pull.values([....]),\n  <span class=\"hljs-comment\">//perform an async job in parallel,</span>\n  <span class=\"hljs-comment\">//but return results in the same order as they went in.</span>\n  paramap(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data, cb</span>) </span>{\n    asyncJob(data, cb)\n  }, width), <span class=\"hljs-comment\">//optional number.</span>\n             <span class=\"hljs-comment\">//limits stream to process width items at once</span>\n  pull.collect(cb)\n)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,16],"version":"1.1.6","npmName":"pull-paramap","category":"combinators"},{"user":"pull-stream","name":"pull-pair","path":"pull-stream/pull-pair","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-pair\">pull-pair</a><div class=\"contrib\"></div></h1>\n<p>A pair of {source, sink} streams that are internally connected,\n(what goes into the sink comes out the source)</p>\n<p>This can be used to construct pipelines that are connected.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pair = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-pair&apos;</span>)\n\n<span class=\"hljs-keyword\">var</span> p = pair()\n\n<span class=\"hljs-comment\">//read values into this sink...</span>\npull(pull.values([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]), p.sink)\n\n<span class=\"hljs-comment\">//but that should become the source over here.</span>\npull(p.source, pull.collect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, values</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(err) <span class=\"hljs-keyword\">throw</span> err\n  <span class=\"hljs-built_in\">console</span>.log(values) <span class=\"hljs-comment\">//[1, 2, 3]</span>\n}))</code></pre>\n<p>This is particularily useful for creating duplex streams especilaly\naround servers. Use <code>pull-pair/duplex</code> to get two duplex streams\nthat are attached to each other.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> DuplexPair = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-pair/duplex&apos;</span>)\n\n<span class=\"hljs-keyword\">var</span> d = DuplexPair()\n\n<span class=\"hljs-comment\">//the &quot;client&quot;: pipe to the first duplex and get the response.</span>\npull(\n  pull.values([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]),\n  d[<span class=\"hljs-number\">0</span>],\n  pull.collect(<span class=\"hljs-built_in\">console</span>.log) <span class=\"hljs-comment\">// =&gt; 10, 20, 30</span>\n)\n\n<span class=\"hljs-comment\">//the &quot;server&quot;: pipe from the second stream back to itself</span>\n<span class=\"hljs-comment\">//(in this case) appling a transformation.</span>\npull(\n  d[<span class=\"hljs-number\">1</span>],\n  pull.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> e*<span class=\"hljs-number\">10</span>\n  }),\n  d[<span class=\"hljs-number\">1</span>]\n)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.1.0","npmName":"pull-pair","category":"combinators"},{"user":"pull-stream","name":"pull-through","path":"pull-stream/pull-through","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-through\">pull-through</a><div class=\"contrib\"></div></h1>\n<p><a href=\"https://github.com/dominictarr/through\">through</a> ported to\n<a href=\"https://github.com/dominictarr/pull-stream\">pull-stream</a> style.</p>\n<h2>Example</h2>\n<p>Same Good Old Api, Brand New Underlying Mechanism.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> through = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-through&apos;</span>)\n\n<span class=\"hljs-keyword\">var</span> ts = through(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.queue(data)\n}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">end</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.queue(<span class=\"hljs-literal\">null</span>)\n})</code></pre>\n<h2>Incompatibility</h2>\n<h3>DON&apos;T</h3>\n<p>use <code>var self = this</code>, don&apos;t keep a reference.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> WRONG = through(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{ WRONG.queue(data) })</code></pre>\n<h3>DO</h3>\n<pre><code class=\"hljs language-js\">through(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{ <span class=\"hljs-keyword\">this</span>.queue(data) })</code></pre>\n<p>Maybe this will change. this is a little more tricky with pull-streams, though.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.0.18","npmName":"pull-through","category":"combinators"},{"user":"pull-stream","name":"pull-traverse","path":"pull-stream/pull-traverse","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-traverse\">pull-traverse</a><div class=\"contrib\"></div></h1>\n<p><a href=\"https://travis-ci.org/dominictarr/pull-traverse\"></a></p>\n<h2>depthFirst, widthFirst, leafFirst (start, createStream)</h2>\n<p>Traverse a tree structure. <code>start</code> is a value that represents\na node. <code>createStream</code> is a function that returns\na pull-stream of the children of a node.\n<code>start</code> must be the same type output by <code>createStream</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pt   = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-traverse&apos;</span>)\n\npull(\n  pt.widthFirst(objects, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">object</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(object &amp;&amp; <span class=\"hljs-string\">&apos;object&apos;</span> === <span class=\"hljs-keyword\">typeof</span> object)\n      <span class=\"hljs-keyword\">return</span> pull.values(object)\n    <span class=\"hljs-keyword\">return</span> pull.empty()\n  }),\n  pull.log()\n)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.0.3","npmName":"pull-traverse","category":"combinators"},{"user":"pull-stream","name":"pull-window","path":"pull-stream/pull-window","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-window\">pull-window</a><div class=\"contrib\"></div></h1>\n<p>Aggregate a pull-stream into windows.</p>\n<p>Several helpers are provided for particular types of windows,\nsliding, tumbling, etc.</p>\n<p>And also, a low level</p>\n<h2>Example: &quot;tumbling&quot; window</h2>\n<p>sum every 10 items.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull   = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">window</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-window&apos;</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">everyTen</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-comment\">//window calls init with each data item,</span>\n  <span class=\"hljs-comment\">//and a callback to close that window.</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data, cb</span>) </span>{\n    <span class=\"hljs-comment\">//if you don&apos;t want to start a window here,</span>\n    <span class=\"hljs-comment\">//return undefined</span>\n    <span class=\"hljs-keyword\">if</span>(i != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-number\">0</span>\n\n    <span class=\"hljs-comment\">//else return a function.</span>\n    <span class=\"hljs-comment\">//this will be called all data</span>\n    <span class=\"hljs-comment\">//until you callback.</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">end, data</span>) </span>{\n      <span class=\"hljs-keyword\">if</span>(end) <span class=\"hljs-keyword\">return</span> cb(<span class=\"hljs-literal\">null</span>, sum)\n      sum += data\n      <span class=\"hljs-keyword\">if</span>(++i &gt;= <span class=\"hljs-number\">10</span>) {\n        i = <span class=\"hljs-number\">0</span>\n        cb(<span class=\"hljs-literal\">null</span>, sum)\n      }\n    }\n  }\n}\n\npull(\n  pull.count(<span class=\"hljs-number\">1000</span>),\n  everyTen(),\n  pull.log()\n)</code></pre>\n<h2>Example: variable sized window</h2>\n<p>Each window doesn&apos;t have to be the same size...</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull   = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">window</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-window&apos;</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">groupTo100</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">_, cb</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(sum != <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span>\n\n    <span class=\"hljs-comment\">//sum stuff together until you have 100 or more</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">end, data</span>) </span>{\n      <span class=\"hljs-keyword\">if</span>(end) <span class=\"hljs-keyword\">return</span> cb(<span class=\"hljs-literal\">null</span>, sum)\n      sum += data\n      <span class=\"hljs-keyword\">if</span>(sum &gt;= <span class=\"hljs-number\">100</span>) {\n        <span class=\"hljs-comment\">//copy sum like this, incase the next item</span>\n        <span class=\"hljs-comment\">//comes through sync</span>\n        <span class=\"hljs-keyword\">var</span> _sum = sum; sum = <span class=\"hljs-literal\">null</span>\n        cb(<span class=\"hljs-literal\">null</span>, _sum)\n      }\n    }\n  })\n}\n\npull(\n  pull.count(<span class=\"hljs-number\">1000</span>)\n  groupTo100(),\n  pull.log()\n)</code></pre>\n<h2>Example: sliding window</h2>\n<p>to make more over lapping windows\njust return the window function more often.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull   = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">window</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-window&apos;</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sliding</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">_, cb</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-number\">0</span>, i = <span class=\"hljs-number\">0</span>\n\n    <span class=\"hljs-comment\">//sum stuff together until you have 100 or more</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">end, data</span>) </span>{\n      <span class=\"hljs-keyword\">if</span>(end) <span class=\"hljs-keyword\">return</span> cb(<span class=\"hljs-literal\">null</span>, sum)\n      sum += data\n      <span class=\"hljs-keyword\">if</span>(++i &gt;= <span class=\"hljs-number\">10</span>) {\n        <span class=\"hljs-comment\">//in this example, each window gets it&apos;s own sum,</span>\n        <span class=\"hljs-comment\">//so we don&apos;t need to copy it.</span>\n        cb(<span class=\"hljs-literal\">null</span>, sum)\n      }\n    }\n  })\n}\n\npull(\n  pull.count(<span class=\"hljs-number\">100</span>)\n  sliding(),\n  pull.log()\n)</code></pre>\n<h2>API</h2>\n<h3>window (start, map)</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-built_in\">window</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">startWindow</span> (<span class=\"hljs-params\">data, cb</span>) </span>{\n\n  <span class=\"hljs-comment\">//called on each chunk</span>\n  <span class=\"hljs-comment\">//including the first one</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addToWindow</span> (<span class=\"hljs-params\">end, data</span>) </span>{\n    <span class=\"hljs-comment\">//cb(null, aggregate) when done.</span>\n  }\n}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mapWindow</span> (<span class=\"hljs-params\">start, data</span>) </span>{\n  <span class=\"hljs-comment\">//(optional)</span>\n  <span class=\"hljs-comment\">//map the window to something that tracks start, also</span>\n})</code></pre>\n<p>By default, windows are mapped to <code>{start: firstData, data: aggregate}</code>.\nunless you pass in an different <code>mapWindow</code> function.</p>\n<h3>window.sliding(reduce, size)</h3>\n<p>reduce every <code>size</code> items into a single value, in a sliding window</p>\n<h3>window.recent(size, time)</h3>\n<p>tumbling window that groups items onto an array,\neither every <code>size</code> items, or within <code>time</code> ms,\nwhich ever occurs earliest.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,1],"version":"2.1.4","npmName":"pull-window","category":"combinators"},{"user":"pull-stream","name":"pull-pushable","path":"pull-stream/pull-pushable","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-pushable\">pull-pushable</a><div class=\"contrib\"></div></h1>\n<p>A pull-stream with a pushable interface.</p>\n<p>Use this when you really can&apos;t pull from your source.\nFor example, often I like to have a &quot;live&quot; stream.\nThis would read a series of data, first old data,\nbut then stay open and read new data as it comes in.</p>\n<p>In that case, the new data needs to be queued up while the old data is read,\nand also, the rate things are pushed into the queue doesn&apos;t affect the rate of reads.</p>\n<p>If there is no realtime aspect to this stream, it&apos;s likely that you don&apos;t need pushable.\nInstead try just using <code>pull.values(array)</code>.</p>\n<h2>Example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> Pushable = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-pushable&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pull     = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> p = Pushable()\n\npull(p, pull.drain(<span class=\"hljs-built_in\">console</span>.log))\n\np.push(<span class=\"hljs-number\">1</span>)\np.end()</code></pre>\n<p>Also, can provide a listener for when the stream is closed.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> Pushable = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-pushable&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pull     = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> p = Pushable(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;stream closed!&apos;</span>)\n})\n\n<span class=\"hljs-comment\">//read 3 times then abort.</span>\npull(p, pull.take(<span class=\"hljs-number\">3</span>), pull.drain(<span class=\"hljs-built_in\">console</span>.log))\n\np.push(<span class=\"hljs-number\">1</span>)\np.push(<span class=\"hljs-number\">2</span>)\np.push(<span class=\"hljs-number\">3</span>)\np.push(<span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">//stream will be aborted before this is output</span></code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,1],"version":"2.0.0","npmName":"pull-pushable","category":"push"},{"user":"pull-stream","name":"pull-notify","path":"pull-stream/pull-notify","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-notify\">pull-notify</a><div class=\"contrib\"></div></h1>\n<p>Notify many listeners via pull-streams.</p>\n<p>you could use when you might otherwise use an event emitter.\nWhy not just use an event emitter? EventEmitters have a weird\nsecurity contract: anyone who can listen can also emit,\nand they can emit or listen to any events!</p>\n<p>Instead, events should travel down a single channel,\nand the ability to emit an event should be separated from\nthe ability to listen.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> Notify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-notify&apos;</span>)\n\n<span class=\"hljs-keyword\">var</span> notify = Notify()\n\n<span class=\"hljs-comment\">//create a pull stream that listens on events.</span>\n<span class=\"hljs-comment\">//it will eventually get all events.</span>\npull(notify.listen(), pull.drain(<span class=\"hljs-built_in\">console</span>.log))\n\nnotify(<span class=\"hljs-string\">&apos;hello&apos;</span>) <span class=\"hljs-comment\">//emit an event.</span>\n\nnotify.end() <span class=\"hljs-comment\">//tell all listeners it&apos;s over.</span></code></pre>\n<p>listers can abort (using the normal pull-stream abort),\nand that will remove them from the list.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"0.1.0","npmName":"pull-notify","category":"push"},{"user":"pull-stream","name":"pull-glob","path":"pull-stream/pull-glob","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-glob\">pull-glob</a><div class=\"contrib\"></div></h1>\n<p>streaming extended glob.</p>\n<p>use with <a href=\"https://github.com/dominictarr/pull-stream\">pull-stream</a></p>\n<h2>examples</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> glob = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-glob&apos;</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">glob_log</span> (<span class=\"hljs-params\">name, pattern</span>) </span>{\n  pull(glob(pattern), pull.collect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, ary</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(err) <span class=\"hljs-keyword\">throw</span> err\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;name:&apos;</span>, name, <span class=\"hljs-string\">&apos;pattern:&apos;</span>, pattern)\n    <span class=\"hljs-built_in\">console</span>.log(ary)\n  })\n}\n\n\nglob_log(<span class=\"hljs-string\">&apos;current dir&apos;</span>, <span class=\"hljs-string\">&apos;.&apos;</span>)\nglob_log(<span class=\"hljs-string\">&apos;js in current dir&apos;</span>, <span class=\"hljs-string\">&apos;*.js&apos;</span>)\nglob_log(<span class=\"hljs-string\">&apos;everything under current dir&apos;</span>, <span class=\"hljs-string\">&apos;**&apos;</span>)\nglob_log(<span class=\"hljs-string\">&apos;all js under current dir&apos;</span>, <span class=\"hljs-string\">&apos;**/*.js&apos;</span>)\nglob_log(<span class=\"hljs-string\">&apos;parent directories&apos;</span>, <span class=\"hljs-string\">&apos;...&apos;</span>)\nglob_log(<span class=\"hljs-string\">&apos;hidden files&apos;</span>, <span class=\"hljs-string\">&apos;.../.*&apos;</span>)\nglob_log(<span class=\"hljs-string\">&apos;available modules&apos;</span>, <span class=\"hljs-string\">&apos;.../node_modules/*&apos;</span>)\nglob_log(<span class=\"hljs-string\">&apos;local package files&apos;</span>, <span class=\"hljs-string\">&apos;.../{package,component}.json&apos;</span>)</code></pre>\n<h2>stopping early</h2>\n<p>because this module uses pull-streams, it&apos;s lazy,\nso you can do queries like the following:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//find the first package.json in a parent directory.</span>\npull(glob(<span class=\"hljs-string\">&apos;.../package.json&apos;</span>), pull.take(<span class=\"hljs-number\">1</span>), log())</code></pre>\n<p>And you will retrive only the first item, and <em>will\nnot do any extra IO</em>. This is hugely useful when\ndoing a large traversal...</p>\n<h2>collect node_module tree</h2>\n<pre><code class=\"hljs language-js\">pull(\n  glob(<span class=\"hljs-string\">&apos;**/node_modules/*/package.json&apos;</span>),\n  pull.collect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e, arr</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(arr)\n  })\n)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.0.6","npmName":"pull-glob","category":"file system and databases"},{"user":"pull-stream","name":"pull-level","path":"pull-stream/pull-level","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-level\">pull-level</a><div class=\"contrib\"></div></h1>\n<p><a href=\"https://github.com/dominictarr/pull-stream\">pull-stream</a> interface to\n<a href=\"https://github.com/rvagg/node-levelup\">levelup</a></p>\n<h2>Example - reading</h2>\n<p>read items in database.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pl = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-level&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n\n<span class=\"hljs-keyword\">var</span> db = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;levelup&apos;</span>)(<span class=\"hljs-string\">&apos;/tmp/pull-level-example&apos;</span>)\n\npull(pl.read(db), pull.collect(<span class=\"hljs-built_in\">console</span>.log))</code></pre>\n<p>read items in database, plus realtime changes</p>\n<pre><code class=\"hljs language-js\">pull(\n  pl.read(db, {tail: <span class=\"hljs-literal\">true</span>}),\n  <span class=\"hljs-comment\">//log data as it comes,</span>\n  <span class=\"hljs-comment\">//because tail will keep the connection open</span>\n  <span class=\"hljs-comment\">//so we&apos;ll never see the end otherwise.</span>\n  pull.through(<span class=\"hljs-built_in\">console</span>.log),\n  <span class=\"hljs-comment\">//note, pull-streams will not drain unless something is</span>\n  <span class=\"hljs-comment\">//pulling the data through, so we have to add drain</span>\n  <span class=\"hljs-comment\">//even though the data we want is coming from pull.through()</span>\n  pull.drain()\n)</code></pre>\n<p>If you just want the realtime inserts,\nuse <code>live</code></p>\n<pre><code class=\"hljs language-js\">pull(\n  pl.live(db, {tail: <span class=\"hljs-literal\">true</span>}),\n  pull.through(<span class=\"hljs-built_in\">console</span>.log),\n  pull.drain()\n)</code></pre>\n<h2>Example - writing</h2>\n<p>To write, pipe batch changes into <code>write</code></p>\n<pre><code class=\"hljs language-js\">pull(\n  pull.values([\n    {key: <span class=\"hljs-number\">0</span>, value: <span class=\"hljs-string\">&apos;zero&apos;</span>, type: <span class=\"hljs-string\">&apos;put&apos;</span>},\n    {key: <span class=\"hljs-number\">1</span>, value: <span class=\"hljs-string\">&apos;one&apos;</span>,  type: <span class=\"hljs-string\">&apos;put&apos;</span>},\n    {key: <span class=\"hljs-number\">2</span>, value: <span class=\"hljs-string\">&apos;two&apos;</span>,  type: <span class=\"hljs-string\">&apos;put&apos;</span>},\n  ]),\n  pl.write(db)\n)</code></pre>\n<p>If you are lazy/busy, you can leave off <code>type</code>.\nIn that case, if <code>value</code> is non-null, the change\nis considered a <code>put</code> else, a <code>del</code>.</p>\n<pre><code class=\"hljs language-js\">pull(\n  pull.values([\n    {key: <span class=\"hljs-number\">0</span>, value: <span class=\"hljs-string\">&apos;zero&apos;</span>},\n    {key: <span class=\"hljs-number\">1</span>, value: <span class=\"hljs-string\">&apos;one&apos;</span>},\n    {key: <span class=\"hljs-number\">2</span>, value: <span class=\"hljs-string\">&apos;two&apos;</span>},\n  ]), \n  pl.write(db)\n)</code></pre>\n<h2>Example - indexes!</h2>\n<p>With pull-level it&apos;s easy to create indexes.\njust save a pointer to the key.</p>\n<p>like this:</p>\n<pre><code class=\"hljs language-js\">pull(\n  pull.values([\n    {key: key, value: VALUE, type: <span class=\"hljs-string\">&apos;put&apos;</span>},\n    {key: <span class=\"hljs-string\">&apos;~INDEX~&apos;</span> + VALUE.prop, value: key,  type: <span class=\"hljs-string\">&apos;put&apos;</span>},\n  ]),\n  pl.write(db)\n)</code></pre>\n<p>then, when you want to do a <code>read</code>, use <code>asyncMap</code></p>\n<pre><code class=\"hljs language-js\">pull(\n  pl.read(db, {min: <span class=\"hljs-string\">&apos;~INDEX~&apos;</span>, max: <span class=\"hljs-string\">&apos;~INDEX~~&apos;</span>})\n  pull.asyncMap(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e, cb</span>) </span>{\n    db.get(e.value, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>{\n      cb(<span class=\"hljs-literal\">null</span>, {key: e.value, value: value})\n    })\n  }),\n  pull.collect(<span class=\"hljs-built_in\">console</span>.log)\n)</code></pre>\n<h2>Example realtime aggregation</h2>\n<p>We want to keep a realtime count of everything in the database.\nWhen ever something is inserted, we increment. But, we need\nto check the records that are <em>currently</em> in the database.</p>\n<p>Since it takes some time to scan the database, we need to make sure\nwe have done that before giving an answer. We can read it all with\none stream, using <code>{sync: true}</code> to be notified of when we have read out all the old records.</p>\n<p>First all the old records are read from the non-live stream,\nthen you get one <code>{sync: true}</code> element, then all the new item.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-number\">0</span>, ready = <span class=\"hljs-literal\">false</span>, waiting = []\n\n<span class=\"hljs-comment\">//call get count to know s</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getSum</span> (<span class=\"hljs-params\">cb</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!ready) waiting.push(cb)\n  <span class=\"hljs-keyword\">else</span> cb(<span class=\"hljs-literal\">null</span>, sum)\n}\n\npull(\n  pl.read(db, {sync: <span class=\"hljs-literal\">true</span>}),\n  pull.drain(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">op</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(op.sync) {\n      <span class=\"hljs-comment\">//if we see a data element with this it means</span>\n      ready = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">while</span>(waiting.length) waiting.shift()(<span class=\"hljs-literal\">null</span>, count)\n    }\n    <span class=\"hljs-comment\">//increment our counter!</span>\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Number</span>.isFinite(+op.value.amount)) <span class=\"hljs-comment\">//filter out non numbers &amp; NaN.</span>\n      sum += op.value.amount\n  })\n)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.5.2","npmName":"pull-level","category":"file system and databases"},{"user":"dominictarr","name":"pull-fs","path":"dominictarr/pull-fs","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/dominictarr/pull-fs\">pull-fs</a><div class=\"contrib\"></div></h1>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.1.6","npmName":"pull-fs","category":"file system and databases"},{"user":"pull-stream","name":"pull-split","path":"pull-stream/pull-split","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-split\">pull-split</a><div class=\"contrib\"></div></h1>\n<p><a href=\"https://github.com/dominictarr/split\">split</a> ported to\n<a href=\"https://github.com/dominictarr/pull-stream\">pull-stream</a> style.</p>\n<h2>Example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> split = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-split&apos;</span>)\n\npull(\n  textStream\n  split(),\n  output\n)</code></pre>\n<p>if the textStream is buffers, and contain UTF8\n(it probably will if you have german or chinese friends, etc)\nthen you MUST use this with <code>pull-utf8-decoder</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> split = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-split&apos;</span>)\n<span class=\"hljs-keyword\">var</span> utf8 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-utf8-decoder&apos;</span>)\n\npull(\n  textStream\n  utf8(),\n  split(),\n  output\n)</code></pre>\n<h2>split(matcher, mapper, reverse, skipLast)</h2>\n<h3>matcher - string or regexp.</h3>\n<p>unit to split by, defaults to <code>\\n</code></p>\n<h3>mapper - function</h3>\n<p>function to apply to each line matched.</p>\n<h3>reverse - boolean</h3>\n<p>if true, emit lines in reverse. use this if the input is a file\nyou are reading backwards.</p>\n<h3>skipLast - boolean</h3>\n<p>use this to skip the last value if it is and empty string <code>&apos;&apos;</code>\nif this is not set then the behavior is the same as <code>String#split</code></p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,3],"version":"0.2.0","npmName":"pull-split","category":"text"},{"user":"pull-stream","name":"pull-stringify","path":"pull-stream/pull-stringify","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stringify\">pull-stringify</a><div class=\"contrib\"></div></h1>\n<p>JSON.stringify as pull stream</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> stringify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stringify&apos;</span>)\n<span class=\"hljs-keyword\">var</span> toPull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;stream-to-pull-stream&apos;</span>)\n\npull(\n  pull.value([A, B, C]),\n  stringify(),\n  toPull(process.stdout)\n)</code></pre>\n<p><code>pull-stringify</code> takes the same arguments as\n<a href=\"https://github.com/dominictarr/JSONStream#jsonstreamstringifyopen-sep-close\">JSONStream.stringify</a> but as a pull stream.</p>\n<p>Also if you want line separated json, a default is provided:</p>\n<pre><code class=\"hljs language-js\">pull(\n  pull.value([A, B, C]),\n  stringify.lines(),\n  toPull(process.stdout)\n)</code></pre>\n<p>to use a non-custom stringifyer use the final argument.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//compatible with JSON but supports buffers.</span>\n<span class=\"hljs-keyword\">var</span> JSONB = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;json-buffer&apos;</span>)\n\n<span class=\"hljs-comment\">//use defaults for op, cl, and sep</span>\nstringify(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, JSONB.stringify)\n\n<span class=\"hljs-comment\">//or</span>\nstringify.lines(JSONB.stringify)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.2.2","npmName":"pull-stringify","category":"text"},{"user":"pull-stream","name":"pull-handshake","path":"pull-stream/pull-handshake","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-handshake\">pull-handshake</a><div class=\"contrib\"></div></h1>\n<p>create handshakes for binary protocols with pull streams.</p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> shake = handshake()\n\n<span class=\"hljs-comment\">//pull some amount of data out of the stream</span>\nshake.read(<span class=\"hljs-number\">32</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>{\n\n  <span class=\"hljs-comment\">//write a response...</span>\n  shake.write(<span class=\"hljs-keyword\">new</span> Buffer(<span class=\"hljs-string\">&apos;hello there&apos;</span>))\n\n  shake.read(<span class=\"hljs-number\">32</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>{\n    <span class=\"hljs-comment\">//get a confirmation,</span>\n    <span class=\"hljs-comment\">//and then attach the application</span>\n    <span class=\"hljs-keyword\">var</span> stream = createApplicationStream()\n    pull(stream, shake.rest(), stream)\n    <span class=\"hljs-comment\">//shake.rest() returns a duplex binary stream.</span>\n\n  })\n\n})\n\n\n<span class=\"hljs-comment\">//shake is itself a duplex pull-stream.</span>\npull(shake, stream, shake)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,10],"version":"1.1.2","npmName":"pull-handshake","category":"binary"},{"user":"dominictarr","name":"pull-randomly-split","path":"dominictarr/pull-randomly-split","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/dominictarr/pull-randomly-split\">pull-randomly-split</a><div class=\"contrib\"></div></h1>\n<p>randomly split incoming buffers, to test that parsing works correctly.</p>\n<pre><code class=\"hljs language-js\">pull(\n  pull.values(crypto.randomBytes(<span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>)),\n  randomSplit(<span class=\"hljs-number\">1024</span>, <span class=\"hljs-number\">2096</span>),\n  pull.collect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n\n\n  })\n)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.0.4","npmName":"pull-randomly-split","category":"binary"},{"user":"dominictarr","name":"pull-reader","path":"dominictarr/pull-reader","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/dominictarr/pull-reader\">pull-reader</a><div class=\"contrib\"></div></h1>\n<p>read bytes from a binary pull-stream</p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> Reader = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-reader&apos;</span>)\n<span class=\"hljs-keyword\">var</span> File = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-file&apos;</span>)\n<span class=\"hljs-keyword\">var</span> reader = Reader(<span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">//1 second timeout, abort upstream if read takes longer than this.</span>\n\n\npull(\n  File(<span class=\"hljs-string\">&apos;./package.json&apos;</span>),\n  reader\n)\n\n<span class=\"hljs-comment\">//read the first byte of a file</span>\nreader.read(<span class=\"hljs-number\">1</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(data.toString()) <span class=\"hljs-comment\">// =&gt; {</span>\n})</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.2.5","npmName":"pull-reader","category":"binary"},{"user":"DamonOehlman","name":"pull-ws","path":"DamonOehlman/pull-ws","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/DamonOehlman/pull-ws\">pull-ws</a><div class=\"contrib\"></div></h1>\n<p>A simple (but effective) implementation of a\n<a href=\"https://github.com/dominictarr/pull-stream\"><code>pull-stream</code></a> <code>Source</code> and <code>Sink</code>\nthat is compatible both with native browser WebSockets and\n<a href=\"https://github.com/einaros/ws\"><code>ws</code></a> created clients.</p>\n<p><a href=\"https://nodei.co/npm/pull-ws/\"></a></p>\n<p><a href=\"https://github.com/dominictarr/stability#unstable\"></a> <a href=\"https://travis-ci.org/DamonOehlman/pull-ws\"></a></p>\n<h2>Reference</h2>\n<h3><code>pws(socket, opts?)</code></h3>\n<p>turn a websocket into a duplex pull stream.\nIf provided, <code>opts</code> is passed to <code>pws.sink(socket, opts)</code>.</p>\n<p>Websockets do not support half open mode.\n<a href=\"http://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener\">see allowHalfOpen option in net module</a></p>\n<p>If you have a protocol that assumes halfOpen connections, but are using\na networking protocol like websockets that does not support it, I suggest\nusing <a href=\"https://github.com/dominictarr/pull-goodbye\">pull-goodbye</a> with your\nprotocol.</p>\n<p>The duplex stream will also contain a copy of the properties from\nthe http request that became the websocket. they are <code>method</code>, <code>url</code>,\n<code>headers</code> and <code>upgrade</code>.</p>\n<h3><code>pws.sink(socket, opts?)</code></h3>\n<p>Create a pull-stream <code>Sink</code> that will write data to the <code>socket</code>.\n<code>opts</code> may be <code>{closeOnEnd: true, onClose: onClose}</code>.\n<code>onClose</code> will be called when the sink ends. If <code>closeOnEnd=false</code>\nthe stream will not close, it will just stop emitting data.\n(by default <code>closeOnEnd</code> is true)</p>\n<p>If <code>opts</code> is a function, then <code>onClose = opts; opts.closeOnEnd = true</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>);\n<span class=\"hljs-keyword\">var</span> ws = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-ws&apos;</span>);\n\n<span class=\"hljs-comment\">// connect to the echo endpoint for test/server.js</span>\n<span class=\"hljs-keyword\">var</span> socket = <span class=\"hljs-keyword\">new</span> WebSocket(<span class=\"hljs-string\">&apos;wss://echo.websocket.org&apos;</span>);\n\n<span class=\"hljs-comment\">// write values to the socket</span>\npull(\n  pull.infinite(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&apos;hello @ &apos;</span> + <span class=\"hljs-built_in\">Date</span>.now()\n  }),\n  <span class=\"hljs-comment\">// throttle so it doesn&apos;t go nuts</span>\n  pull.asyncMap(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, cb</span>) </span>{\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n      cb(<span class=\"hljs-literal\">null</span>, value);\n    }, <span class=\"hljs-number\">100</span>);\n  }),\n  ws.sink(socket)\n);\n\nsocket.addEventListener(<span class=\"hljs-string\">&apos;message&apos;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">evt</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;received: &apos;</span> + evt.data);\n});</code></pre>\n<h3><code>pws.source(socket)</code></h3>\n<p>Create a pull-stream <code>Source</code> that will read data from the <code>socket</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>);\n\n<span class=\"hljs-comment\">// we just need the source, so cherrypick</span>\n<span class=\"hljs-keyword\">var</span> ws = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-ws/source&apos;</span>);\n\npull(\n  <span class=\"hljs-comment\">// connect to the test/server.js endpoint</span>\n  ws(<span class=\"hljs-keyword\">new</span> WebSocket(<span class=\"hljs-string\">&apos;ws://localhost:3000/read&apos;</span>)),\n  pull.log()\n);</code></pre>\n<h2>License(s)</h2>\n<h3>ISC</h3>\n<p>Copyright (c) 2014, Damon Oehlman <a href=\"http://github.com/DamonOehlman/pull-ws/blob/master/mailto:damon.oehlman@gmail.com\">damon.oehlman@gmail.com</a></p>\n<p>Permission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.</p>\n<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.</p>\n","contributors":[17,0],"version":"2.3.0","npmName":"pull-ws","category":"networks"},{"user":"pull-stream","name":"pull-ws-server","path":"pull-stream/pull-ws-server","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-ws-server\">pull-ws-server</a><div class=\"contrib\"></div></h1>\n<p>create pull stream websockets, servers, and clients.</p>\n<h2>example</h2>\n<p>one duplex service you may want to use this with is <a href=\"https://github.com/dominictarr/muxrpc\">muxrpc</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> ws = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-ws-server&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n\nws.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">stream</span>) </span>{\n  <span class=\"hljs-comment\">//pipe duplex style to your service.</span>\n  pull(stream, service.createStream(), stream)\n})\n.listen(<span class=\"hljs-number\">9999</span>)\n\n<span class=\"hljs-keyword\">var</span> stream = ws.connect(<span class=\"hljs-string\">&apos;ws://localhost:9999&apos;</span>)\n\npull(stream, client.createStream(), stream)</code></pre>\n<p>if the connection fails, the first read from the stream will be an error,\notherwise, to get a handle of stream end/error pass a callback to connect.</p>\n<pre><code class=\"hljs language-js\">ws.connect(<span class=\"hljs-string\">&apos;ws://localhost:9999&apos;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, stream</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(err) <span class=\"hljs-keyword\">return</span> handleError(err)\n  <span class=\"hljs-comment\">//stream is now ready</span>\n})</code></pre>\n<p>To run the server over TLS:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> tlsOpts = {\n  key: fs.readFileSync(<span class=\"hljs-string\">&apos;test/fixtures/keys/agent2-key.pem&apos;</span>),\n  cert: fs.readFileSync(<span class=\"hljs-string\">&apos;test/fixtures/keys/agent2-cert.pem&apos;</span>)\n};\nws.createServer(tlsOpts, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">stream</span>) </span>{\n  <span class=\"hljs-comment\">//pipe duplex style to your service.</span>\n  pull(stream, service.createStream(), stream)\n})\n.listen(<span class=\"hljs-number\">9999</span>)</code></pre>\n<p>To add client-authentication to the server, you can set <code>verifyClient</code>.\n<a href=\"https://github.com/websockets/ws/blob/master/doc/ws.md#optionsverifyclient\">Documentation here</a>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">verifyClient</span> (<span class=\"hljs-params\">info</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> info.secure == <span class=\"hljs-literal\">true</span>\n}\nws.createServer({ verifyClient: verifyClient }, onStream)</code></pre>\n<h2>use with an http server</h2>\n<p>if you have an http server that you also need to serve stuff\nover, and want to use a single port, use the <code>server</code> option.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;http&apos;</span>)\n<span class=\"hljs-keyword\">var</span> server = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req, res</span>)</span>{...}).listen(....)\nws.createServer({server: server}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">stream</span>) </span>{ ... })</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,10,16],"version":"1.9.2","npmName":"pull-ws-server","category":"networks"},{"user":"ssbc","name":"muxrpc","path":"ssbc/muxrpc","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/ssbc/muxrpc\">muxrpc</a><div class=\"contrib\"></div></h1>\n<p>combined rpc and multiplexing, with pull-streams.</p>\n<p><a href=\"http://travis-ci.org/ssbc/muxrpc\"></a></p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> MRPC = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;muxrpc&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n\n<span class=\"hljs-comment\">//we need a manifest of methods we wish to expose.</span>\n<span class=\"hljs-keyword\">var</span> api = {\n  <span class=\"hljs-comment\">//async is a normal async function</span>\n  hello: <span class=\"hljs-string\">&apos;async&apos;</span>,\n\n  <span class=\"hljs-comment\">//source is a pull-stream (readable)</span>\n  stuff: <span class=\"hljs-string\">&apos;source&apos;</span>\n\n  <span class=\"hljs-comment\">//<span class=\"hljs-doctag\">TODO:</span> sink and duplex pull-streams</span>\n}\n\n<span class=\"hljs-comment\">//pass the api into the constructor, and then pass the object you are wrapping</span>\n<span class=\"hljs-comment\">//(if there is a local api)</span>\n<span class=\"hljs-keyword\">var</span> client = MRPC(api, <span class=\"hljs-literal\">null</span>) () <span class=\"hljs-comment\">//remoteApi, localApi</span>\n<span class=\"hljs-keyword\">var</span> server = MRPC(<span class=\"hljs-literal\">null</span>, api) ({\n  hello: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name, cb</span>) </span>{\n    cb(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&apos;hello, &apos;</span> + name + <span class=\"hljs-string\">&apos;!&apos;</span>)\n  },\n  stuff: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> pull.values([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>])\n  }\n})\n\n<span class=\"hljs-keyword\">var</span> a = client.createStream()\n<span class=\"hljs-keyword\">var</span> b = server.createStream()\n\npull(a, b, a) <span class=\"hljs-comment\">//pipe together</span>\n\nclient.hello(<span class=\"hljs-string\">&apos;world&apos;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, value</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(err) <span class=\"hljs-keyword\">throw</span> err\n  <span class=\"hljs-built_in\">console</span>.log(value)\n  <span class=\"hljs-comment\">// hello, world!</span>\n})\n\npull(client.stuff(), pull.drain(<span class=\"hljs-built_in\">console</span>.log))\n<span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-comment\">// 4</span>\n<span class=\"hljs-comment\">// 5</span></code></pre>\n<h2>Manifest</h2>\n<p>like multilevel, a <a href=\"https://github.com/juliangruber/multilevel#plugins\">manifest is required</a>\nexcept it works a little differently, and since muxrpc works with any api,\nnot assuming leveldb then you must write the manifest yourself.</p>\n<p>The manifest is simply an object mapping to strings, or nested objects.</p>\n<pre><code class=\"hljs language-js\">{\n  foo: <span class=\"hljs-string\">&apos;async&apos;</span>,        <span class=\"hljs-comment\">//a function with a callback.</span>\n  bar: <span class=\"hljs-string\">&apos;sync&apos;</span>,         <span class=\"hljs-comment\">//a function that returns a value</span>\n                       <span class=\"hljs-comment\">//(note this is converted to an async function for the client)</span>\n  allTheFoos: <span class=\"hljs-string\">&apos;source&apos;</span> <span class=\"hljs-comment\">//a source pull-stream (aka, readable)</span>\n  writeFoos: <span class=\"hljs-string\">&apos;sink&apos;</span>,   <span class=\"hljs-comment\">//a sink pull-stream (aka, writable)</span>\n  fooPhone: <span class=\"hljs-string\">&apos;duplex&apos;</span>,  <span class=\"hljs-comment\">//a duplex pull-stream</span>\n\n  <span class=\"hljs-comment\">//create nested objects like this:</span>\n  bar: {\n    ...\n  }\n}</code></pre>\n<h2>Permissions</h2>\n<p>If you are exposing an api over a network connection,\nthen you probably want some sort of authorization system.\n<code>muxrpc@4</code> and earlier had a <code>rpc.permissions()</code> method on\nthe rpc object, but this has been removed.\nNow you must pass a permissions function, which is called with\nthe <code>name</code> (a path) and <code>args</code>, if this function does not throw\nan error, then the call is allowed.</p>\n<p>In some cases, a simple allow/deny list is sufficient.\nA helper function, is provided, which was a part of muxrpc@4</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> Permissions = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;muxrpc/permissions&apos;</span>)\n\n<span class=\"hljs-keyword\">var</span> api = {\n  foo: <span class=\"hljs-string\">&apos;async&apos;</span>,\n  bar: <span class=\"hljs-string\">&apos;async&apos;</span>,\n  auth: <span class=\"hljs-string\">&apos;async&apos;</span>\n}\n\n<span class=\"hljs-comment\">//set initial settings</span>\n<span class=\"hljs-keyword\">var</span> perms = Perms({allow: [<span class=\"hljs-string\">&apos;auth&apos;</span>]})\n\n<span class=\"hljs-keyword\">var</span> rpc = muxrpc(<span class=\"hljs-literal\">null</span>, api, serializer)({\n  foo: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, cb</span>) </span>{\n    cb(<span class=\"hljs-literal\">null</span>, {okay: <span class=\"hljs-string\">&apos;foo&apos;</span>})\n  },\n  bar: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, cb</span>) </span>{\n    cb(<span class=\"hljs-literal\">null</span>, {okay: <span class=\"hljs-string\">&apos;bar&apos;</span>})\n  },\n  auth: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">pass</span>) </span>{\n    <span class=\"hljs-comment\">//implement an auth function that sets the permissions,</span>\n    <span class=\"hljs-comment\">//using allow or deny lists.</span>\n\n    <span class=\"hljs-keyword\">if</span>(pass === <span class=\"hljs-string\">&apos;whatever&apos;</span>)\n      perms({deny: [<span class=\"hljs-string\">&apos;bar&apos;</span>]}) <span class=\"hljs-comment\">//allow everything except &quot;bar&quot;</span>\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pass === <span class=\"hljs-string\">&apos;s3cr3tz&apos;</span>)\n      perms({}) <span class=\"hljs-comment\">//allow everything!!!</span>\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> cb(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&apos;ACCESS DENIED&apos;</span>))\n\n    <span class=\"hljs-comment\">//else we ARE authorized.</span>\n    cb(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&apos;ACCESS GRANTED&apos;</span>)\n  }\n}, perms)\n\n<span class=\"hljs-comment\">//Get a stream to connect to the remote. As in the above example!</span>\n<span class=\"hljs-keyword\">var</span> ss = rpc.createStream()</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,10,18,5],"version":"6.3.3","npmName":"muxrpc","category":"networks"},{"user":"pull-stream","name":"stream-to-pull-stream","path":"pull-stream/stream-to-pull-stream","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/stream-to-pull-stream\">stream-to-pull-stream</a><div class=\"contrib\"></div></h1>\n<p>Convert a classic-stream, or a new-stream into a\n<a href=\"https://github.com/dominictarr/pull-stream\">pull-stream</a></p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> toPull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;stream-to-pull-stream&apos;</span>)\n<span class=\"hljs-keyword\">var</span> pull = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream&apos;</span>)\n\npull(\n  toPull.source(fs.createReadStream(__filename)),\n  pull.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>{ <span class=\"hljs-keyword\">return</span> e.toString().toUpperCase() }),\n  toPull.sink(process.stdout, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(err) <span class=\"hljs-keyword\">throw</span> err\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;done&apos;</span>)\n  })\n)</code></pre>\n<p>if the node steam is a duplex (i.e. net, ws) then use <code>toPull.duplex(stream, cb?)</code>\n<code>duplex</code> takes an optional callback in the same way that <code>sink</code> does.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,19],"version":"1.6.8","npmName":"stream-to-pull-stream","category":"interop"},{"user":"pull-stream","name":"pull-stream-to-stream","path":"pull-stream/pull-stream-to-stream","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream-to-stream\">pull-stream-to-stream</a><div class=\"contrib\"></div></h1>\n<p>turn a pull-stream into a regular node stream.</p>\n<h2>example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> toStream = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-stream-to-stream&apos;</span>)\n\n<span class=\"hljs-comment\">//if the pull-stream is duplex (an object with two streams: {source, sink})</span>\n\nstream = toStream(pullDuplex)\n\n<span class=\"hljs-comment\">//if the stream is a sink (&quot;writable&quot;)</span>\nstream = toStream.sink(pullSink)\n\n<span class=\"hljs-comment\">//if the stream is a source (&quot;readable&quot;)</span>\n\nstream = toStream.source(pullSource)</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0],"version":"1.3.0","npmName":"pull-stream-to-stream","category":"interop"},{"user":"dominictarr","name":"pull-box-stream","path":"dominictarr/pull-box-stream","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/dominictarr/pull-box-stream\">pull-box-stream</a><div class=\"contrib\"></div></h1>\n<p>stream <em>one way</em> encryption based on <a href=\"https://github.com/paixaop/node-sodium\">libsodium</a>&apos;s secretbox primitive.</p>\n<p></p>\n<p>This protocol should not be used to encrypt a tcp connection\nunless it was combined with a handshake protocol\nthat was used to derive a forward secure shared key.</p>\n<p>It may be used to encrypt a file.</p>\n<h2>Claims</h2>\n<h3>All bytes are authenticated &amp; encrypted.</h3>\n<ul>\n<li>The reciever never reads an unauthenticated number of bytes.</li>\n</ul>\n<p>This protects against attackers causing deadlocks on certain application protocols protected with box-stream.\n(description of this attack on\n<a href=\"https://github.com/calvinmetcalf/hmac-stream/issues/5\">old version of hmac-stream</a>)</p>\n<ul>\n<li>The end of the stream is authenticated.</li>\n</ul>\n<p>This detects if an attacker cut off the end of the stream.\nfor example:</p>\n<p>Alice: hey bob, just calling to say that I think TLS is really great,\nreally elegant protocol, and that I love everything about it.</p>\n<p>Mallory (man in the middle): (SNIP! ...terminates connection...)</p>\n<p>Alice: NOT!!!!! (Bob never receives this!)</p>\n<p>Bob... WTF, I thought Alice had taste!</p>\n<p>Bob never gets the punchline, so thinks that Alice&apos;s childish humor was\nactually her sincere belief.</p>\n<p>With box-stream this would result in an error and Bob would know\nthat there was some additional content he missed which hopefully\nexplained Alice&apos;s absurd statement.</p>\n<h2>Disclaims</h2>\n<ul>\n<li>This protocol does not obscure packet boundries or packet timing.</li>\n<li>This protocol is not a substitute for TLS, it must be used with another handshake protocol to derive a shared key.</li>\n</ul>\n<h2>Protocol</h2>\n<p>This protocol has no malleable bytes.\nEven the framing is authenticated, and since the framing is\nauthenticated separately to the packet content, an attacker cannot\nflip any bits without being immediately detected.</p>\n<p>The design follows on from that used in\n<a href=\"https://github.com/dominictarr/pull-mac\">pull-mac</a>,\nwhere both the framing and the framed packet are authenticated.</p>\n<p>In <code>pull-mac</code>, the packet is hashed, and then the header hmac&apos;d.\nSince the header contains the packet hash and the packet length,\nthen changing a bit in the packet will produce a different hash\nand thus an invalid packet. Flipping a bit in the header will\ninvalidate the hmac.</p>\n<p>In <code>pull-boxes</code> a similar approach is used, but via nacl&apos;s authenticated\nencryption primitive: <code>secretbox</code>. salsa20 encryption + poly1305 mac.\nThe packet is boxed, then the header is constructed from the packet\nlength + packet mac, then the header is boxed.</p>\n<p>This protocol uses a 56 byte key (448 bits). The first 32 bytes\nare the salsa20 key, and the last 24 bytes are the nonce. Previous\nverisons of this protocol generated a nonce and transmitted it,\nbut it could be simplified by considering it part of the key.</p>\n<p>Since every header and packet body are encrypted,\nthen every byte in the stream appears random.</p>\n<p>The only information an evesdropper can extract is\npacket timing and to guess at packet boundries\n(although, sometimes packets will be appended, obscuring the true boundries)</p>\n<h2>Example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> boxes = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;pull-box-stream&apos;</span>)\n<span class=\"hljs-comment\">//generate a random secret, 56 bytes long.</span>\n\n<span class=\"hljs-keyword\">var</span> key = createRandomSecret(<span class=\"hljs-number\">56</span>)\n\npull(\n  plaintext_input,\n\n  <span class=\"hljs-comment\">//encrypt every byte</span>\n  boxes.createBoxStream(key),\n\n  <span class=\"hljs-comment\">//the encrypted stream</span>\n  pull.through(<span class=\"hljs-built_in\">console</span>.log),\n\n  <span class=\"hljs-comment\">//decrypt every byte</span>\n  boxes.createUnboxStream(key),\n\n  plaintext_output\n)</code></pre>\n<h2>Protocol</h2>\n<pre><code>(\n\n  [header MAC (16)] // sends header MAC\n     |\n     |   .--header-box-----------------.\n     \\-&gt; |length (2), [packet MAC (16)]| // sends encrypted header\n         `--^------------|-------------`\n            |            |\n            |            |  .-packet-box-------.\n            |            `-&gt;|data.. (length...)| // sends encrypted packet\n            |               `-----------|------`\n            \\---------------------------/\n\n) * // repeat 0-N times\n\n[final header MAC(16)]\n   |\n   |  .-final-header-box-------.\n   \\-&gt;|length=0 (2), zeros (16)|\n      `------------------------`\n</code></pre>\n<p>Since the packet mac is inside the header box, the packet\nmust be boxed first.</p>\n<p>The last 24 bytes of the 56 byte key is used as the nonce.\nWhen boxing, you must use a different nonce everytime a particular key is used.</p>\n<p>The recommended way to do this is to randomly generate an initial\nnonce for that key, and then increment that nonce on each boxing.\n(this way security is not dependant on the random number generator)</p>\n<p>The protocol sends zero or more {header, packet} pairs, then a final\nheader, that is same length, but is just boxed zeros.\nEach header is 34 bytes long (header mac + packet_length + packet mac).\nThen the packet_length is length long (with a maximum length of 4096\nbytes long, if the in coming packet is longer than that it is split\ninto 4096 byte long sections.)</p>\n<p>Packet number P uses N+2P as the nonce on the header box,\nand N+2P+1 as the nonce on the packet box.</p>\n<p>A final packet is sent so that an incorrectly terminated session\ncan be detected.</p>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,20],"version":"1.0.11","npmName":"pull-box-stream","category":"crypto"},{"user":"auditdrivencrypto","name":"secret-handshake","path":"auditdrivencrypto/secret-handshake","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/auditdrivencrypto/secret-handshake\">secret-handshake</a><div class=\"contrib\"></div></h1>\n<p>secure-channel based on a a mutually authenticating key agreement handshake, with forward secure identity metadata.</p>\n<p>For a full explaination of the design, read the\n<a href=\"http://dominictarr.github.io/secret-handshake-paper/shs.pdf\">Design Paper</a></p>\n<h2>Claims</h2>\n<p>This protocol derives shared keys and mutually\nauthenticates both ends of the connection.\nThe shared secrets are forward secure, and\nso is the identity metadata.</p>\n<p>by &quot;forward secure identity metadata&quot; I mean:</p>\n<ul>\n<li>a later key compromise cannot confirm the public keys in the handshake.</li>\n</ul>\n<p>And also:</p>\n<ul>\n<li>an eavesdropper cannot learn public keys</li>\n<li>replay attacker cannot learn public keys.</li>\n<li>man in the middle cannot learn public keys.</li>\n<li>a &quot;wrong number&quot; cannot learn public keys.</li>\n<li>an unauthenticated client cannot learn server key.</li>\n</ul>\n<blockquote>\n<p>note: a wrong number is just an accidental man in the middle.</p>\n</blockquote>\n<p>By &quot;confirm&quot; I mean check a guess at the public key.\nBy &quot;learn&quot; I mean that you can <em>either</em> extract the public key,\nor confirm the public key.</p>\n<p>Also note that if the server decides not to authenticate a client,\nit will learn their public key. To get to this stage, the client\nmust know the server&apos;s key, so now the client and server both\nknow each others key. This is fair.</p>\n<h2>Disclaims</h2>\n<p>This protocol cannot hide your ip address.\nThis protocol does not attempt to obscure packet boundries.\nIf a man in the middle or wrong number later compromises\nthe server&apos;s key, they will be able to extract the client\nkey from the client&apos;s hello packet.</p>\n<h2>Example</h2>\n<p>The simplest way to use secret-handshake is to use\n<code>require(&apos;secret-handshake/net&apos;)</code>, a wrapper around net.\nThis makes it easy to create encrypted tcp connections.</p>\n<p><a href=\"https://github.com/dominictarr/pull-streams\">pull-streams</a> are used.\nlearn about how pull-streams from <a href=\"https://github.com/dominictarr/pull-stream-examples\">these examples</a></p>\n<p><a href=\"https://github.com/paixaop/node-sodium\">sodium</a> is required to generate\nkey pairs.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> createNode = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;secret-handshake/net&apos;</span>)\n<span class=\"hljs-keyword\">var</span> sodium = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;sodium&apos;</span>).api\n<span class=\"hljs-keyword\">var</span> appKey = ... <span class=\"hljs-comment\">//32 random bytes</span>\n<span class=\"hljs-keyword\">var</span> aliceKey = sodium.crypto_sign_keypair() <span class=\"hljs-comment\">//client</span>\n<span class=\"hljs-keyword\">var</span> bobKey = sodium.crypto_sign_keypair()   <span class=\"hljs-comment\">//server</span>\n\n<span class=\"hljs-keyword\">var</span> alice = createNode({\n  keys: aliceKey,\n  appKey: appKey\n})\n\n<span class=\"hljs-keyword\">var</span> bob = createNode({\n  keys: bobKey,\n  appKey: appKey,\n  <span class=\"hljs-comment\">//the authenticate function is required to receive calls.</span>\n  authenticate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">pub, cb</span>) </span>{\n    <span class=\"hljs-comment\">//decide whether to allow access to pub.</span>\n    <span class=\"hljs-keyword\">if</span>(yes) cb(<span class=\"hljs-literal\">null</span>, truthy)\n    <span class=\"hljs-keyword\">else</span>    cb(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&apos;reason&apos;</span>))\n    <span class=\"hljs-comment\">//The client WILL NOT see the unauthentication reason</span>\n  }\n})\n\n<span class=\"hljs-comment\">//now, create a server (bob) and connect a client (alice)</span>\n\nbob.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">stream</span>) </span>{\n  pull(source, stream, sink)\n}).listen(<span class=\"hljs-number\">8978</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> stream =\n    alice.connect({port: <span class=\"hljs-number\">8979</span>, host: <span class=\"hljs-string\">&apos;localhost&apos;</span>, keys: bob.publicKey})\n\n  pull(source, stream, sink)\n})</code></pre>\n<h2>License</h2>\n<p>MIT</p>\n","contributors":[0,21,10],"version":"0.4.1","npmName":"secret-handshake","category":"crypto"},{"user":"pull-stream","name":"sources/count","path":"pull-stream/pull-stream","subpath":"sources/count","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sources/count.md\">pull-stream/sources/count</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sources/empty","path":"pull-stream/pull-stream","subpath":"sources/empty","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sources/empty.md\">pull-stream/sources/empty</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sources/error","path":"pull-stream/pull-stream","subpath":"sources/error","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sources/error.md\">pull-stream/sources/error</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sources/infinite","path":"pull-stream/pull-stream","subpath":"sources/infinite","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sources/infinite.md\">pull-stream/sources/infinite</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sources/keys","path":"pull-stream/pull-stream","subpath":"sources/keys","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sources/keys.md\">pull-stream/sources/keys</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sources/once","path":"pull-stream/pull-stream","subpath":"sources/once","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sources/once.md\">pull-stream/sources/once</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sources/values","path":"pull-stream/pull-stream","subpath":"sources/values","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sources/values.md\">pull-stream/sources/values</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/async-map","path":"pull-stream/pull-stream","subpath":"throughs/async-map","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/async-map.md\">pull-stream/throughs/async-map</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/filter-not","path":"pull-stream/pull-stream","subpath":"throughs/filter-not","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/filter-not.md\">pull-stream/throughs/filter-not</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/filter","path":"pull-stream/pull-stream","subpath":"throughs/filter","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/filter.md\">pull-stream/throughs/filter</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/flatten","path":"pull-stream/pull-stream","subpath":"throughs/flatten","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/flatten.md\">pull-stream/throughs/flatten</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/map","path":"pull-stream/pull-stream","subpath":"throughs/map","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/map.md\">pull-stream/throughs/map</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/non-unique","path":"pull-stream/pull-stream","subpath":"throughs/non-unique","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/non-unique.md\">pull-stream/throughs/non-unique</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/take","path":"pull-stream/pull-stream","subpath":"throughs/take","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/take.md\">pull-stream/throughs/take</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/through","path":"pull-stream/pull-stream","subpath":"throughs/through","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/through.md\">pull-stream/throughs/through</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"throughs/unique","path":"pull-stream/pull-stream","subpath":"throughs/unique","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/throughs/unique.md\">pull-stream/throughs/unique</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sinks/collect","path":"pull-stream/pull-stream","subpath":"sinks/collect","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sinks/collect.md\">pull-stream/sinks/collect</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sinks/concat","path":"pull-stream/pull-stream","subpath":"sinks/concat","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sinks/concat.md\">pull-stream/sinks/concat</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sinks/drain","path":"pull-stream/pull-stream","subpath":"sinks/drain","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sinks/drain.md\">pull-stream/sinks/drain</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sinks/find","path":"pull-stream/pull-stream","subpath":"sinks/find","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sinks/find.md\">pull-stream/sinks/find</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sinks/log","path":"pull-stream/pull-stream","subpath":"sinks/log","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sinks/log.md\">pull-stream/sinks/log</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sinks/on-end","path":"pull-stream/pull-stream","subpath":"sinks/on-end","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sinks/on-end.md\">pull-stream/sinks/on-end</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"sinks/reduce","path":"pull-stream/pull-stream","subpath":"sinks/reduce","readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/pull-stream/pull-stream/blob/master/sinks/reduce.md\">pull-stream/sinks/reduce</a><div class=\"contrib\"></div></h1>\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"version":false,"npmName":false,"category":"core"}]}